<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Reflection" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="System.CodeDom" #>
<#@ output extension=".cs" #>
<#
    init("cs");
#>
/*
    This is an autogenerated class any manual edits to this file will be lost the next time this class is generated
    This file was last generated on <#= DateTime.Now.ToString() #> from the Assembly: <#= asm #>
*/
namespace <#= libNameSpace #>.Dto
{
    //ROOT ENTITIES
    <#
    foreach(Type eObj in GetRootEntities())
    {
        PrintEntity(eObj);
    }
    #>


    //DEPENDENCIES
    <#
    for(int i=0; i< Dependencies.Count(); i++)
    {
        PrintEntity(Dependencies[i]);
    }
    CleanUp();
    #>
}<#+
    private Assembly asm;
    private string libNameSpace = "";
    private List<Type> Dependencies= new List<Type>();
    private string lang;

    private void init(string language)
    {
        System.IO.FileInfo tmpFile = new System.IO.FileInfo(this.Host.ResolveAssemblyReference("$(TargetPath)"));
        asm = Assembly.Load(System.IO.File.ReadAllBytes(tmpFile.FullName));
        libNameSpace = tmpFile.Name.Replace(tmpFile.Extension, "");

        lang = language;
    }

    private List<Type> GetRootEntities()
    {
        List<Type> tmpReturn = new List<Type>();
        
        foreach (Type tmpEnt in asm.GetTypes())
        {
            if(tmpEnt.BaseType.Name == "RootAggregate")
                tmpReturn.Add(tmpEnt);
        }
        return tmpReturn;
    }

    private List<PropertyInfo> GetProperties(Type t)
    {
        List<PropertyInfo> tmpReturn = new List<PropertyInfo>();

        foreach(PropertyInfo p in t.GetProperties())
        {
            if(p.PropertyType.Assembly.FullName == asm.FullName && !Dependencies.Contains(t.GetType()))
                Dependencies.Add(p.PropertyType);

            tmpReturn.Add(p);
        }

        return tmpReturn;
    }

    private void PrintEntity(Type t)
    {
        ClearIndent();
        PushIndent("    ");

        switch(lang.ToLower())
        {
        case "cs":
                WriteLine("public class {0}Dto", t.Name);
                WriteLine("{");
                PushIndent("    ");
                foreach(PropertyInfo p in GetProperties(t))
                {
                    string type = IsSimple(p.PropertyType) ? GetCompilerType(p.PropertyType) : p.PropertyType.Name + "Dto";
                    WriteLine("{0} {1} {{get; set;}}", type, p.Name);
                }
                PopIndent();
                WriteLine("}");
                break;
        }

        ClearIndent();
    }

    private bool IsSimple(Type t)
    {
        //TODO: FIND A BETTER WAY TO DETERMINE IF IT'S A SYSTEM TYPE
        return t.IsPrimitive 
            || t.IsEnum
            || t.Equals(typeof(string))
            || t.Equals(typeof(decimal))
            || t.Equals(typeof(DateTime));
    }

    //USED TO GENERATE A COMPILER TYPE FROM LOOK UP ie INT32 = int
    private string GetCompilerType(Type t)
    {
        using(var compiler = new CSharpCodeProvider())
        {
            var type = new CodeTypeReference(t);
            return compiler.GetTypeOutput(type);
        }
    }

    private void CleanUp()
    {
        //HACK: NOT SURE OF A BETTER WAY TO CLEAR OUT THE ASSEBMLY TO GENERATING THE CLASS DOESN'T LOCK THE OUTPUT DLL/EXE
        asm = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
    }
#>